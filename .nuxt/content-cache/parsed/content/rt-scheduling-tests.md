{"parsed":{"_path":"/rt-scheduling-tests","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Dynamic scheduling visualization with Cheddar","description":"Lets get a visual perspective and implement some code!","recommended":true,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"scheduling-algorithms"},"children":[{"type":"text","value":"Scheduling algorithms"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Welcome to this Scheduling Tutorial! I have talked about scheduling methods in the past, in this post we will be looking more in depth at some algorithms and implement one at the end!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I will be using 'cheddar' which is program for visualizing hyper frames:\n"},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://beru.univ-brest.fr/cheddar/","rel":["nofollow"]},"children":[{"type":"text","value":"http://beru.univ-brest.fr/cheddar/"}]}]}]},{"type":"element","tag":"h1","props":{"id":"rms-vs-edf-scheduling-algorithms"},"children":[{"type":"text","value":"RMS vs EDF scheduling algorithms"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets create a Monotonic (pre-emptive fixed priority scheduler) with the following tasks:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Task T1: Capacity = 2, Deadline = 4, Period = 4, Start Time = 0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Task T2: Capacity = 5, Deadline = 10, Period = 10, Start Time = 0"}]},{"type":"element","tag":"h2","props":{"id":"rms-rate-monotonic-scheduling"},"children":[{"type":"text","value":"RMS (Rate-monotonic scheduling)"}]},{"type":"element","tag":"img","props":{"src":"/img/1_RMS.png","width":600,"height":180},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RMS is an algorithm for managing the priority of static tasks, jobs with a shorter cycle duration are assigned a higher pirority, shortest duration jobs having the highest."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using this method, T2 misses it's deadline at 11 and cannot execute fully in time. This is an example of how RMS does not work for the given the task paramters. Lets try EDF next."}]},{"type":"element","tag":"h2","props":{"id":"edf-earliest-deadline-first"},"children":[{"type":"text","value":"EDF (Earliest deadline first)"}]},{"type":"element","tag":"img","props":{"src":"/img/1_EDF.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When using EDF we see this issue is fixed, both tasks are capable of executing given their constraints - the system containts the same amount of context switches and overall performance!"}]},{"type":"element","tag":"h1","props":{"id":"edf-vs-llf-scheduling-algorithms"},"children":[{"type":"text","value":"EDF vs LLF scheduling algorithms"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Given the following task:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Task T1: Capacity = 3, Deadline = 9, Period = 9, Start Time = 0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Task T2: Capacity = 4, Deadline = 8, Period = 8, Start Time = 0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets compare EDF with LLF."}]},{"type":"element","tag":"h2","props":{"id":"edf-earliest-deadline-first-1"},"children":[{"type":"text","value":"EDF (Earliest deadline first)"}]},{"type":"element","tag":"img","props":{"src":"/img/2_EDF.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With EDF, no deadlines are missed but notice the difference in context switches."}]},{"type":"element","tag":"h2","props":{"id":"llf-least-laxity-first"},"children":[{"type":"text","value":"LLF (Least laxity first)"}]},{"type":"element","tag":"h2","props":{"id":"laxity-dealine-current-time-remaining-processing-time"},"children":[{"type":"text","value":"Laxity = dealine - (current time + remaining processing time)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The task with the least laxity is given the highest priority for execution. This is a preeptive algorith which means a running task can be preempted (interrupted) by another task with a higher priority."}]},{"type":"element","tag":"img","props":{"src":"/img/2_LLF.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Least laxity first shows a great amount of task switching and introduces 18 preemptions. We can see from the diagram that this approach is quite computationally intensive."}]},{"type":"element","tag":"h1","props":{"id":"nap-vs-pip-scheduling-algorithms"},"children":[{"type":"text","value":"NAP vs PIP scheduling algorithms"}]},{"type":"element","tag":"h2","props":{"id":"lets-introduce-some-resources-for-focus-on-resource-access-and-management"},"children":[{"type":"text","value":"Lets introduce some resources for focus on resource access and management"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We will use mutexes to appropriately manage access (mutex free methods are often used but are much more difficutl to implement and are used in a case by case basis)."}]},{"type":"element","tag":"h2","props":{"id":"no-access-control"},"children":[{"type":"text","value":"No access control"}]},{"type":"element","tag":"img","props":{"src":"/img/3_NAP.png","width":600,"height":160},"children":[]},{"type":"element","tag":"h2","props":{"id":"priority-inversion"},"children":[{"type":"text","value":"Priority inversion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"From the diagram we can see a new timeline (resource S) indicating when a lock is gained (blue block) and released (red block). Due to incorrect resource control we can see that task 1 misses its deadline in its second period. This is because Task 1 is preempted by Task 2 - this is known as "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"priority inversion"}]},{"type":"text","value":". Task 2 is a lower priority task but holds the lock for the shared resource that a higher priority task (task 1) needs. We need a way to manage resource access so tasks are not waiting for accesses and being missed."}]},{"type":"element","tag":"h2","props":{"id":"access-control-using-pip-priority-inheritance-protocol"},"children":[{"type":"text","value":"Access control using PIP (Priority inheritance protocol)"}]},{"type":"element","tag":"img","props":{"src":"/img/3_PIP.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The diagram above shows PIP introducing an extra context switch to successfully complete the execution of all tasks for their hyper period. The priority inversion has been prevented!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When a high-priority task is blocked because a lower-priority task holds a resource it needs, the lower-priority task \"inherits\" the higher priority of the blocking task. This temporary priority boost helps the lower-priority task to complete its use of the shared resource more quickly, thereby reducing the waiting time for the higher-priority task. Once the lower-priority task releases the resource, it reverts to its original priority."}]},{"type":"element","tag":"h1","props":{"id":"pip-deadlock-condition-and-pcp"},"children":[{"type":"text","value":"PIP deadlock condition and PCP"}]},{"type":"element","tag":"h2","props":{"id":"dead-lock"},"children":[{"type":"text","value":"Dead lock"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We must watchout for deadlocks when using PIP"}]},{"type":"element","tag":"h2","props":{"id":"pip-deadlock"},"children":[{"type":"text","value":"PIP deadlock"}]},{"type":"element","tag":"img","props":{"src":"/img/4_PIP_dead.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Figure above showcases a deadlock bweteen two tasks are they both wait for the other to release a lock for a shared resource"}]},{"type":"element","tag":"h2","props":{"id":"pcp"},"children":[{"type":"text","value":"PCP"}]},{"type":"element","tag":"img","props":{"src":"/img/4_PCP.png","width":600,"height":160},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets use PCP to prevent the deadlock as per the above"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"rms-rate-monotonic-scheduling","depth":2,"text":"RMS (Rate-monotonic scheduling)"},{"id":"edf-earliest-deadline-first","depth":2,"text":"EDF (Earliest deadline first)"},{"id":"edf-earliest-deadline-first-1","depth":2,"text":"EDF (Earliest deadline first)"},{"id":"llf-least-laxity-first","depth":2,"text":"LLF (Least laxity first)"},{"id":"laxity-dealine-current-time-remaining-processing-time","depth":2,"text":"Laxity = dealine - (current time + remaining processing time)"},{"id":"lets-introduce-some-resources-for-focus-on-resource-access-and-management","depth":2,"text":"Lets introduce some resources for focus on resource access and management"},{"id":"no-access-control","depth":2,"text":"No access control"},{"id":"priority-inversion","depth":2,"text":"Priority inversion"},{"id":"access-control-using-pip-priority-inheritance-protocol","depth":2,"text":"Access control using PIP (Priority inheritance protocol)"},{"id":"dead-lock","depth":2,"text":"Dead lock"},{"id":"pip-deadlock","depth":2,"text":"PIP deadlock"},{"id":"pcp","depth":2,"text":"PCP"}]}},"_type":"markdown","_id":"content:rt-scheduling-tests.md","_source":"content","_file":"rt-scheduling-tests.md","_extension":"md"},"hash":"Lxa7lTxtan"}