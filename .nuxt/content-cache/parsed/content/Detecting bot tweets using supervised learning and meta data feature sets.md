{"parsed":{"_path":"/detecting-bot-tweets-using-supervised-learning-and-meta-data-feature-sets","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Modeling an ml model for detecting bots in a social network","description":"Using logictic regression and RF","recommended":true,"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This model is based on the following paper:\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9358734","rel":["nofollow"]},"children":[{"type":"text","value":"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9358734"}]}]}]},{"type":"element","tag":"h1","props":{"id":"load-the-data"},"children":[{"type":"text","value":"Load the data"}]},{"type":"element","tag":"pre","props":{"code":"import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\n\ndata = pd.read_csv(\"datasets/twitter_human_bots_dataset.csv\")\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\n\ndata = pd.read_csv(\"datasets/twitter_human_bots_dataset.csv\")\n"}]}]},{"type":"element","tag":"h1","props":{"id":"drop-unnecessary-columns"},"children":[{"type":"text","value":"Drop unnecessary columns"}]},{"type":"element","tag":"pre","props":{"code":"columns_to_drop = [\"created_at\", \"description\", \"id\", \"default_profile_image\", \"profile_image_url\", \"screen_name\", \"profile_background_image_url\"]\ndata = data.drop(columns=columns_to_drop)\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"columns_to_drop = [\"created_at\", \"description\", \"id\", \"default_profile_image\", \"profile_image_url\", \"screen_name\", \"profile_background_image_url\"]\ndata = data.drop(columns=columns_to_drop)\n"}]}]},{"type":"element","tag":"h1","props":{"id":"label-encoding-for-account_type"},"children":[{"type":"text","value":"Label encoding for 'account_type'"}]},{"type":"element","tag":"pre","props":{"code":"label_encoder = LabelEncoder()\ndata['account_type'] = label_encoder.fit_transform(data['account_type'])\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"label_encoder = LabelEncoder()\ndata['account_type'] = label_encoder.fit_transform(data['account_type'])\n"}]}]},{"type":"element","tag":"h1","props":{"id":"woe-encoding-for-lang-and-location"},"children":[{"type":"text","value":"WoE encoding for 'lang' and 'location'"}]},{"type":"element","tag":"pre","props":{"code":"def calculate_woe(data, column, target_column):\n    woe_dict = {}\n    total_events = data[target_column].sum()\n    total_nonevents = data.shape[0] - total_events\n    \n    for category in data[column].unique():\n        events = data[(data[column] == category) & (data[target_column] == 1)].shape[0]\n        nonevents = data[(data[column] == category) & (data[target_column] == 0)].shape[0]\n        \n        if events == 0:\n            woe_value = -10  # Clip to a reasonable lower value\n        elif nonevents == 0:\n            woe_value = 10   # Clip to a reasonable upper value\n        else:\n            woe_value = np.log((nonevents / total_nonevents) / (events / total_events))\n            # Clip the WoE value to a reasonable range\n            woe_value = max(-10, min(10, woe_value))\n        \n        woe_dict[category] = woe_value\n    \n    return woe_dict\n\nwoe_lang = calculate_woe(data, 'lang', 'account_type')\nwoe_location = calculate_woe(data, 'location', 'account_type')\n\ndata['lang'] = data['lang'].map(woe_lang)\ndata['location'] = data['location'].map(woe_location)\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def calculate_woe(data, column, target_column):\n    woe_dict = {}\n    total_events = data[target_column].sum()\n    total_nonevents = data.shape[0] - total_events\n    \n    for category in data[column].unique():\n        events = data[(data[column] == category) & (data[target_column] == 1)].shape[0]\n        nonevents = data[(data[column] == category) & (data[target_column] == 0)].shape[0]\n        \n        if events == 0:\n            woe_value = -10  # Clip to a reasonable lower value\n        elif nonevents == 0:\n            woe_value = 10   # Clip to a reasonable upper value\n        else:\n            woe_value = np.log((nonevents / total_nonevents) / (events / total_events))\n            # Clip the WoE value to a reasonable range\n            woe_value = max(-10, min(10, woe_value))\n        \n        woe_dict[category] = woe_value\n    \n    return woe_dict\n\nwoe_lang = calculate_woe(data, 'lang', 'account_type')\nwoe_location = calculate_woe(data, 'location', 'account_type')\n\ndata['lang'] = data['lang'].map(woe_lang)\ndata['location'] = data['location'].map(woe_location)\n"}]}]},{"type":"element","tag":"h1","props":{"id":"feature-scaling"},"children":[{"type":"text","value":"Feature scaling"}]},{"type":"element","tag":"pre","props":{"code":"scaler = StandardScaler()\ndata[['friends_count', 'favourites_count']] = scaler.fit_transform(data[['friends_count', 'favourites_count']])\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"scaler = StandardScaler()\ndata[['friends_count', 'favourites_count']] = scaler.fit_transform(data[['friends_count', 'favourites_count']])\n"}]}]},{"type":"element","tag":"h1","props":{"id":"split-the-data-into-training-and-testing"},"children":[{"type":"text","value":"Split the data into training and testing"}]},{"type":"element","tag":"pre","props":{"code":"X = data.drop(columns=['account_type'])\ny = data['account_type']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"X = data.drop(columns=['account_type'])\ny = data['account_type']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n"}]}]},{"type":"element","tag":"h1","props":{"id":"feature-selection-using-a-random-forest-model"},"children":[{"type":"text","value":"Feature selection using a Random Forest model"}]},{"type":"element","tag":"pre","props":{"code":"rf_model = RandomForestClassifier()\nrf_model.fit(X_train, y_train)\nmodel_feature_selector = SelectFromModel(rf_model, prefit=True)\n\nX_train_selected = model_feature_selector.transform(X_train)\nX_test_selected = model_feature_selector.transform(X_test)\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rf_model = RandomForestClassifier()\nrf_model.fit(X_train, y_train)\nmodel_feature_selector = SelectFromModel(rf_model, prefit=True)\n\nX_train_selected = model_feature_selector.transform(X_train)\nX_test_selected = model_feature_selector.transform(X_test)\n"}]}]},{"type":"element","tag":"h1","props":{"id":"train-a-logistic-regression-model-predict-and-evaluate"},"children":[{"type":"text","value":"Train a logistic regression model, predict and evaluate"}]},{"type":"element","tag":"pre","props":{"code":"logistic_regression = LogisticRegression()\nlogistic_regression.fit(X_train_selected, y_train)\n\ny_pred = logistic_regression.predict(X_test_selected)\n\naccuracy_lr = accuracy_score(y_test, y_pred)\n\nprint(f'Accuracy: {accuracy_lr}')\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"logistic_regression = LogisticRegression()\nlogistic_regression.fit(X_train_selected, y_train)\n\ny_pred = logistic_regression.predict(X_test_selected)\n\naccuracy_lr = accuracy_score(y_test, y_pred)\n\nprint(f'Accuracy: {accuracy_lr}')\n"}]}]},{"type":"element","tag":"pre","props":{"code":"Accuracy: 0.671073717948718\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Accuracy: 0.671073717948718\n"}]}]},{"type":"element","tag":"h1","props":{"id":"train-a-random-forest-classifier-predict-and-evaluate"},"children":[{"type":"text","value":"Train a Random Forest classifier, predict and evaluate"}]},{"type":"element","tag":"pre","props":{"code":"rf_classifier = RandomForestClassifier()\nrf_classifier.fit(X_train_selected, y_train)\n\ny_pred = rf_classifier.predict(X_test_selected)\n\naccuracy_rf = accuracy_score(y_test, y_pred)\nprint(f'Accuracy: {accuracy_rf}')\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rf_classifier = RandomForestClassifier()\nrf_classifier.fit(X_train_selected, y_train)\n\ny_pred = rf_classifier.predict(X_test_selected)\n\naccuracy_rf = accuracy_score(y_test, y_pred)\nprint(f'Accuracy: {accuracy_rf}')\n"}]}]},{"type":"element","tag":"pre","props":{"code":"Accuracy: 0.8880876068376068\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Accuracy: 0.8880876068376068\n"}]}]},{"type":"element","tag":"h1","props":{"id":"print-results"},"children":[{"type":"text","value":"Print results"}]},{"type":"element","tag":"pre","props":{"code":"from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score\n\ndef display_scores(model_name, y_true, y_pred, y_prob):\n    accuracy = accuracy_score(y_true, y_pred)\n    precision = precision_score(y_true, y_pred)\n    recall = recall_score(y_true, y_pred)\n    f1 = f1_score(y_true, y_pred)\n    auc = roc_auc_score(y_true, y_prob)\n    \n    print(f\"Model: {model_name}\")\n    print(f\"Accuracy: {accuracy}\")\n    print(f\"Precision: {precision}\")\n    print(f\"Recall: {recall}\")\n    print(f\"F1 Score: {f1}\")\n    print(f\"AUC: {auc}\")\n    print(\"\")\n\ny_pred_lr = logistic_regression.predict(X_test_selected)\ny_prob_lr = logistic_regression.predict_proba(X_test_selected)[:, 1]\n\ny_pred_rf = rf_classifier.predict(X_test_selected)\ny_prob_rf = rf_classifier.predict_proba(X_test_selected)[:, 1]\n\ndisplay_scores(\"Logistic Regression\", y_test, y_pred_lr, y_prob_lr)\ndisplay_scores(\"Random Forest\", y_test, y_pred_rf, y_prob_rf)\n\n","language":"python","meta":"","className":["language-python"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score\n\ndef display_scores(model_name, y_true, y_pred, y_prob):\n    accuracy = accuracy_score(y_true, y_pred)\n    precision = precision_score(y_true, y_pred)\n    recall = recall_score(y_true, y_pred)\n    f1 = f1_score(y_true, y_pred)\n    auc = roc_auc_score(y_true, y_prob)\n    \n    print(f\"Model: {model_name}\")\n    print(f\"Accuracy: {accuracy}\")\n    print(f\"Precision: {precision}\")\n    print(f\"Recall: {recall}\")\n    print(f\"F1 Score: {f1}\")\n    print(f\"AUC: {auc}\")\n    print(\"\")\n\ny_pred_lr = logistic_regression.predict(X_test_selected)\ny_prob_lr = logistic_regression.predict_proba(X_test_selected)[:, 1]\n\ny_pred_rf = rf_classifier.predict(X_test_selected)\ny_prob_rf = rf_classifier.predict_proba(X_test_selected)[:, 1]\n\ndisplay_scores(\"Logistic Regression\", y_test, y_pred_lr, y_prob_lr)\ndisplay_scores(\"Random Forest\", y_test, y_pred_rf, y_prob_rf)\n\n"}]}]},{"type":"element","tag":"pre","props":{"code":"Model: Logistic Regression\nAccuracy: 0.671073717948718\nPrecision: 0.6700616456714018\nRecall: 0.9998000399920016\nF1 Score: 0.8023750300890637\nAUC: 0.8060603400027674\n\nModel: Random Forest\nAccuracy: 0.8880876068376068\nPrecision: 0.9022222222222223\nRecall: 0.9336132773445311\nF1 Score: 0.9176493710691824\nAUC: 0.9458598831098275\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Model: Logistic Regression\nAccuracy: 0.671073717948718\nPrecision: 0.6700616456714018\nRecall: 0.9998000399920016\nF1 Score: 0.8023750300890637\nAUC: 0.8060603400027674\n\nModel: Random Forest\nAccuracy: 0.8880876068376068\nPrecision: 0.9022222222222223\nRecall: 0.9336132773445311\nF1 Score: 0.9176493710691824\nAUC: 0.9458598831098275\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:Detecting bot tweets using supervised learning and meta data feature sets.md","_source":"content","_file":"Detecting bot tweets using supervised learning and meta data feature sets.md","_extension":"md"},"hash":"145S5mkFcv"}