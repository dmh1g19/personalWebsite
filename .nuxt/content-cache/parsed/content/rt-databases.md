{"parsed":{"_path":"/rt-databases","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Database operations in a real time system","description":"Multi threading and scaling!","recommended":true,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"rt-databases"},"children":[{"type":"text","value":"RT databases"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The main topics covered include:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Storing real-time entity state in a database"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Improving and optimising code to reduce dcomputer"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Running multiple tasks interacting through a real-time database"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Measuring and characterising jitter with multiple tasks"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The implementation has been simplified and abstracted so that it can run in a standard laptop or desktop platform. This somewhat disconnects it from reality, but is necessary in order to avoid substantial overhead due to installing libraries or forcing exactly one platform."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets make a 'naive' database system for a realtime system no optimization and an optimized version. We can comapre the two and discus their differences."}]},{"type":"element","tag":"h1","props":{"id":"a-naive-vs-efficient-implementation"},"children":[{"type":"text","value":"A naive vs efficient implementation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A simple and naive implementation of a database where "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"O(Num of accessess * Number of keys)"}]},{"type":"text","value":"\nand doesnt have any multi-threading capabilities."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This version simply uses a vector (much slower than something like a hashmap)"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"private:\nstruct entry {\n    std::string name;\n    std::vector<char> data;\n};\n\nstd::vector<entry> entries;\n\npublic:\nstd::string GetName() const override { \n    return \"naive\";\n}\n\nbool IsThreadSafe() const override { \n    return false;\n}\n\nintptr_t Register(const char *name, size_t size) override {\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size() == size);\n            return 0;\n        }\n    }\n    entries.push_back({ name, std::vector<char>(size, 0) });\n    return 0;\n}\n\nvoid Read(const char *name, intptr_t token, size_t size, void *data) override\n{\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size()==size);\n            memcpy(data, &e.data[0], size);\n            return;\n        }\n    }\n    memset(data, 0, size);\n}\n\nvoid Write(const char *name, intptr_t token, size_t size, const void *data) override {\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size()==size);\n            memcpy(&e.data[0], data, size);\n            return;\n        }\n    }\n    entries.push_back({ name, std::vector<char>(size, 0) });\n    memcpy(&entries.back().data[0], data, size);\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private:\nstruct entry {\n    std::string name;\n    std::vector<char> data;\n};\n\nstd::vector<entry> entries;\n\npublic:\nstd::string GetName() const override { \n    return \"naive\";\n}\n\nbool IsThreadSafe() const override { \n    return false;\n}\n\nintptr_t Register(const char *name, size_t size) override {\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size() == size);\n            return 0;\n        }\n    }\n    entries.push_back({ name, std::vector<char>(size, 0) });\n    return 0;\n}\n\nvoid Read(const char *name, intptr_t token, size_t size, void *data) override\n{\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size()==size);\n            memcpy(data, &e.data[0], size);\n            return;\n        }\n    }\n    memset(data, 0, size);\n}\n\nvoid Write(const char *name, intptr_t token, size_t size, const void *data) override {\n    for(auto &e : entries){\n        if(e.name==name){\n            assert(e.data.size()==size);\n            memcpy(&e.data[0], data, size);\n            return;\n        }\n    }\n    entries.push_back({ name, std::vector<char>(size, 0) });\n    memcpy(&entries.back().data[0], data, size);\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"efficient-version-using-a-hashmap"},"children":[{"type":"text","value":"Efficient version using a hashmap"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets implement a more efficient version this implementation uses a hasmhmap "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"O(1) insertion"}]},{"type":"text","value":" making it much faster at "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"O(Number of accesses)"}]},{"type":"text","value":" but doesn't have any multi-threading capabilities."}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"private:\nstd::unordered_map<std::string, std::vector<char>> entries;\n\npublic:\nstd::string GetName() const override { \n    return \"efficient\";\n}\n\nbool IsThreadSafe() const override { \n    return false;\n}\n\nintptr_t Register(const char *name, size_t size) override {\n    entries[name] = std::vector<char>(size, 0);\n    return 0;\n}\n\nvoid Read(const char *name, intptr_t token, size_t size, void *data) override {\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        assert(it->second.size() == size);\n        memcpy(data, &it->second[0], size);\n    } else {\n        memset(data, 0, size);\n    }\n}\n\nvoid Write(const char *name, intptr_t token, size_t size, const void *data) override {\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        assert(it->second.size() == size);\n        memcpy(&it->second[0], data, size);\n    } else {\n        entries[name] = std::vector<char>(size, 0);\n        memcpy(&entries[name][0], data, size);\n    }\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private:\nstd::unordered_map<std::string, std::vector<char>> entries;\n\npublic:\nstd::string GetName() const override { \n    return \"efficient\";\n}\n\nbool IsThreadSafe() const override { \n    return false;\n}\n\nintptr_t Register(const char *name, size_t size) override {\n    entries[name] = std::vector<char>(size, 0);\n    return 0;\n}\n\nvoid Read(const char *name, intptr_t token, size_t size, void *data) override {\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        assert(it->second.size() == size);\n        memcpy(data, &it->second[0], size);\n    } else {\n        memset(data, 0, size);\n    }\n}\n\nvoid Write(const char *name, intptr_t token, size_t size, const void *data) override {\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        assert(it->second.size() == size);\n        memcpy(&it->second[0], data, size);\n    } else {\n        entries[name] = std::vector<char>(size, 0);\n        memcpy(&entries[name][0], data, size);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"naive-vs-efficient-results"},"children":[{"type":"text","value":"Naive vs efficient results"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The naive implementation has WallTime = O(NumAccesses * NumKeys). So if you double the number of updates\nexecution time doubles (as expected), and if you double the number keys the execution time also doubles (which is bad)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets run the naive and efficient engine with 1000 accesses, 10 keys, and 1 thread."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"By swapping to a hasmap we have incrased the time efficiency substantially. Our system is currently not thread safe."}]},{"type":"element","tag":"img","props":{"src":"/img/1.3-efficient.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n# Multi-threaded, scalable and efficient\n"},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lets make it multi-threaded and efficient in relation to number of accesses on the database and number of threads running a process!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We achieve a scalable solution with the use of fine grained locks for each key, quite efficient and scalable, depending on CPU."}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"private:\nstd::unordered_map<std::string, std::vector<char>> entries;\nstd::unordered_map<std::string, std::shared_mutex> locks;\n\npublic:\nstd::string GetName() const override {\n    return \"scalable\";\n}\n\nbool IsThreadSafe() const {\n    return true;\n}\n\nintptr_t Register(const char* name, size_t size) override {\n    std::unique_lock lock(locks[name]);\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        return 0;\n    }\n    entries[name] = std::vector<char>(size, 0);\n    return entries[name][0];\n}\n\nvoid Read(const char* name, intptr_t token, size_t size, void* data) override {\n    std::shared_lock lock(locks[name]);\n    if (token != 0) {\n        memcpy(data, &token, size);\n    } else {\n        auto search = entries.find(name);\n        if (search != entries.end()) {\n            memcpy(data, &search->second[0], size);\n        }\n    }\n}\n\nvoid Write(const char* name, intptr_t token, size_t size, const void* data) override {\n    std::unique_lock lock(locks[name]); \n    if (token != 0) {\n        memcpy(&token, data, size);\n    } else {\n        auto search = entries.find(name);\n        if (search != entries.end()) {\n            memcpy(&search->second[0], data, size);\n        }\n    }\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private:\nstd::unordered_map<std::string, std::vector<char>> entries;\nstd::unordered_map<std::string, std::shared_mutex> locks;\n\npublic:\nstd::string GetName() const override {\n    return \"scalable\";\n}\n\nbool IsThreadSafe() const {\n    return true;\n}\n\nintptr_t Register(const char* name, size_t size) override {\n    std::unique_lock lock(locks[name]);\n    auto it = entries.find(name);\n    if (it != entries.end()) {\n        return 0;\n    }\n    entries[name] = std::vector<char>(size, 0);\n    return entries[name][0];\n}\n\nvoid Read(const char* name, intptr_t token, size_t size, void* data) override {\n    std::shared_lock lock(locks[name]);\n    if (token != 0) {\n        memcpy(data, &token, size);\n    } else {\n        auto search = entries.find(name);\n        if (search != entries.end()) {\n            memcpy(data, &search->second[0], size);\n        }\n    }\n}\n\nvoid Write(const char* name, intptr_t token, size_t size, const void* data) override {\n    std::unique_lock lock(locks[name]); \n    if (token != 0) {\n        memcpy(&token, data, size);\n    } else {\n        auto search = entries.find(name);\n        if (search != entries.end()) {\n            memcpy(&search->second[0], data, size);\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can see from the graph below, the number of accesses is linear with wall time!"}]},{"type":"element","tag":"img","props":{"src":"/img/1.5-scalabe.png","width":600},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can also observe that WallTime is "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"O(1/NumThreads)"}]},{"type":"text","value":" for number of threads, my computer is very bad - but with some better hardware this curve would look far better!"}]},{"type":"element","tag":"h1","props":{"id":"data-summary-of-operations-on-the-databses-weve-made"},"children":[{"type":"text","value":"Data summary of operations on the databses we've made"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"src":"/img/1.7.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"src":"/img/2.1.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"src":"/img/2.2.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"src":"/img/2.3.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"src":"/img/2.5.png","width":600},"children":[]},{"type":"element","tag":"br","props":{},"children":[]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:rt-databases.md","_source":"content","_file":"rt-databases.md","_extension":"md"},"hash":"PdWppZqTLT"}